# vim: ft=zsh
#
# On OS X we have GNU Date as gdate, on normal operating systems it's just date
if ! type gdate > /dev/null; then
    alias gdate=date
fi

DEBUG=0
if [ 1 -eq "$DEBUG" ]; then
    zmodload zsh/zprof
    # set the trace prompt to include seconds, nanoseconds, script name and
    # line number
    zmodload zsh/datetime
    PS4='+$EPOCHREALTIME %N:%i> '
    # save file stderr to file descriptor 3 and redirect stderr (including
    # trace output) to a file with the script's PID as an extension
    logfile=/tmp/startlog.$$
    echo "Logging to $logfile"
    exec 3>&2 2>$logfile
    # set options to turn on tracing and expansion of commands contained in
    # the prompt
    setopt xtrace prompt_subst
fi

# Fixing OS X Path annoyances
# if [ -x /usr/libexec/path_helper ]; then
#     echo 'Removing the execute flag from the OS X path helper as it is broken'
#     sudo chmod ugo-x /usr/libexec/path_helper
# fi

if [ -x ~/bin/mount_workon ]; then
    export ROOT_DIR=~/
elif [ -x ./bin/mount_workon ]; then
    export ROOT_DIR=./
else;
    export ROOT_DIR=~rick/
fi

# if [ "$TERM" = "xterm" ]; then
#     export TERM=xterm-256color
# fi

if [ -n "$SSH_AUTH_SOCK" ] && [ "$SSH_AUTH_SOCK" != ~/.ssh/auth_sock ] && [ -z "$TMUX" ]; then
    ln -sf "$SSH_AUTH_SOCK" ~/.ssh/auth_sock && export SSH_AUTH_SOCK=~/.ssh/auth_sock
fi

function command_exists(){
    type $1 2>/dev/null | grep -vq ' not found'
}

ticfile="$TERM.ti"
if command_exists tic && [ -f "$ticfile" ]; then
    tic "$ticfile"
fi


# Tool to check the timing of the config file, handy for debugging
T=0
t(){
    T="$(gdate +%s%N)"
}
t
td(){
    # Time delta
    TD="$(($(gdate +%s%N)-T))"
    # Milliseconds
    M="$((TD/1000000))"
    echo -n "Time in milliseconds: ${M}"

    if [ 0 = "$#" ]; then
        echo
    else
        echo " for $@"
    fi
    t
}

# Load some default modules
setopt extendedglob
zmodload -a colors
zmodload -a autocomplete
zmodload -a complist
# autoload -U colors && colors

if [[ "$OSTYPE" == 'darwin'* ]]; then
    [ -z "$LANG" ] && export LANG=en_US.UTF-8
else
    [ -z "$LANG" ] && export LANG=C.UTF-8
    [ -z "$LANGUAGE" ] && export LANGUAGE=C.UTF-8
    [ -z "$LC_ALL" ] && export LC_ALL=C.UTF-8
fi
export TZ=Europe/Amsterdam

# Adding my own completion functions
fpath=(/usr/local/share/zsh-completions $fpath)
fpath=(/usr/local/share/zsh/site-functions/ $fpath)
fpath=(${ROOT_DIR}.zsh/zsh-completions/src $fpath)
fpath=(${ROOT_DIR}.zsh/site-functions $fpath)

# # Antigen bundles
# . ${ROOT_DIR}.antigen.zsh
# antigen bundle WoLpH/zsh-completions src
# antigen bundle git
# antigen bundle svn
# antigen bundle python
# antigen bundle pip
# antigen bundle extract
# antigen bundle sharat87/zsh-vim-mode
# antigen bundle kennethreitz/autoenv
# antigen apply

# $PATH changes are done in .zprofile
export PATH="$PATH:~/bin:${ROOT_DIR}bin"

# Prompts
#export PS1="$(print '%{\e[0;91m%}%n%{\e[0m%}')$(print '%{\e[0;94m%}@%{\e[0m%}')$(print '%{\e[0;92m%}%m%{\e[0m%}')# "
export PS1="$(print '%{\e[38;5;208m%}%n%{\e[0m%}')$(print '%{\e[38;5;33m%}@%{\e[0m%}')$(print '%{\e[38;5;10m%}%m%{\e[0m%}')# "
export ORIGINAL_PS1="$PS1"
export RPS1='%~'
export ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)

# Declare the variable
typeset -A ZSH_HIGHLIGHT_STYLES

# # To differentiate aliases from other command types
# ZSH_HIGHLIGHT_STYLES[alias]='fg=magenta,bold'
# 
# # To have paths colored instead of underlined
# ZSH_HIGHLIGHT_STYLES[path]='fg=cyan'

# To disable highlighting of globbing expressions
ZSH_HIGHLIGHT_STYLES[globbing]='fg=cyan'

# Show the vim mode
# function zle-line-init zle-keymap-select {
#     RPS1="%~ ${${KEYMAP/vicmd/[NORMAL]}/(main|viins)/[INSERT]} $EPS1"
#     zle reset-prompt
# }
# zle -N zle-line-init
# zle -N zle-keymap-select

# Enable Jedi within the normal Python interpreter
export PYTHONSTARTUP="$HOME/.pythonrc.py"
export PIP_DISABLE_PIP_VERSION_CHECK=1
export PIPENV_VENV_IN_PROJECT=true

# Set the java home
test -x /usr/libexec/java_home && export JAVA_HOME=$(/usr/libexec/java_home)

# if we're on ec2, set the hostname to the cluster setting if available
EC2=0
if [ $(hostname | grep -E '^ip-10-') ]; then
    host=$(curl --silent http://169.254.169.254/latest/user-data/ | python -mjson.tool | grep cluster | sed 's/.*: *"\([^"]*\)".*/\1/g')
    if [ "$host" ]; then
        HOST=$host
        EC2=1
    fi
fi

zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate
zstyle ':completion:*' matcher-list '' 'm:{[:lower:]}={[:upper:]}' 'l:|=* r:|=*' 'r:|[._-]=** r:|=**'
zstyle ':completion:*' max-errors 2
zstyle :compinstall filename '~/.zshrc'

# Allow local X access, seems to be needed for OSX to work with X properly...
#if [ -x /usr/bin/xhost ] && [ -n "$DISPLAY" ]; then
#    xhost +$(hostname -s) > /dev/null
#    xhost +$(hostname -f) > /dev/null
#fi

# if [ -x ${ROOT_DIR}bin/start_supervisord ]; then
#     sudo ${ROOT_DIR}bin/start_supervisord
# fi


SSH_KEYS=(~/.ssh/id_rsa ~/.ssh/id_dsa)

if command_exists ssh-agent && [ -z "$SSH_AUTH_SOCK" ]; then
    eval $(ssh-agent) > /dev/null
fi

# Enable keychain or ssh-add
if [ -z "$SSH_AUTH_SOCK" ]; then
    if command_exists keychain; then
        eval $(keychain --ignore-missing -Q -q --eval $SSH_KEYS)
    elif command_exists ssh-add; then
        for key in $SSH_KEYS; do
            if [ -f "$key" ]; then
                if [[ "$OSTYPE" =~ '^(darwin)' ]]; then
	                ssh-add -q -A -K $key
	            else
                    ssh-add -q $key
	            fi
            fi
        done
    fi
fi

# Some convenient aliases
# Enable spellcheck/autocorrect?
# setopt correct
# export SPROMPT="Correct $fg[red]%R$reset_color to $fg[green]%r?$reset_color (Yes, No, Abort, Edit) "

alias mv='nocorrect mv'       # no spelling correction on mv
alias cp='nocorrect cp'       # no spelling correction on cp
alias mkdir='nocorrect mkdir' # no spelling correction on mkdir
alias less='/usr/bin/less -R'

if [[ "$OSTYPE" =~ '^freebsd' ]]; then
    export LS_OPTIONS='-G'
elif [[ "$OSTYPE" =~ '^darwin' ]]; then
    export LS_OPTIONS='--color'
    alias vlc='open -a vlc'
else
    export LS_OPTIONS='--color=auto'
fi

alias ls="ls $LS_OPTIONS"
alias l='ls -A'
alias ll='l -l'
alias qmv='qmv -f do'
alias push='git pull; git push'
export GIT_MERGE_AUTOEDIT=no

# Some people might not like this but I find it convenient. It makes find
# search in symlinks by default
# alias find='find -L'
alias grep='grep --color=auto --directories=skip'
command_exists hub && alias git=hub

# Link vim to the OS X clipboard
if command_exists nvim; then
    alias vim="safe-reattach-to-user-namespace nvim"
    alias vimdiff="safe-reattach-to-user-namespace nvim -d"
    alias view="safe-reattach-to-user-namespace nvim -R"
    export EDITOR=nvim
else
    alias vim="safe-reattach-to-user-namespace vim"
    alias vimdiff="safe-reattach-to-user-namespace vimdiff"
    export EDITOR=vim
fi

alias vi='vim'
alias parallel='parallel --no-notice'
alias feh='/usr/local/bin/feh --auto-zoom --draw-filename --fullscreen --recursive'
alias montage='feh --montage --thumb-height 256 --thumb-width 256 --limit-width 2560'
alias tb='nc termbin.com 9999'
alias isodate='date -u +"%Y-%m-%dT%H:%M:%S"'
alias ssh-copy-id='ssh-copy-id -o ControlPath=none'
#alias mplayer='open -a MplayerX.App --args '

# Little trick to change the name of the shell
# . ${ROOT_DIR}bin/iterm2_helpers

# moved to bin/title
# function title(){
#     if [ "$1" != "default" ]; then
#         echo -ne "\033]0;$1\007"
#         printf "\033k$1\033\\"
#     fi
# }

function mosh(){
    if [ -n "$1" ]; then
        title "$1"
    fi
    /usr/local/bin/mosh $@
    title ""
}

# Little trick to change the name of the shell
function ssh(){
    if [[ "$@" =~ "BatchMode" ]]; then
        /usr/bin/ssh $*
    else
        if [ -n "$1" ]; then
            title "$*"
        fi
        /usr/bin/ssh $*
        title ""
    fi
}


function autossh(){
    if [ -n "$1" ]; then
        title "$1"
    fi
    monitor_port=$((RANDOM % (65000 - 20000) + 20000))
    exec /usr/local/bin/autossh -o ControlMaster=no -M $monitor_port $*
    title ""
}

# Little function to go to a random directory, handy if you have a lot of
# stuff to sort out and don't know where to start ;)
torandomdir(){
    files=(*)
    dir=("${files[RANDOM%${#files[@]}]}")
    cd "$dir"
}

torandomparentdir(){
    cd ..
    echo "$PWD"
    torandomdir
}

# ec2 utils
ec2ssh(){
    host=$(echo $@ | sed 's/.*://')
    label=$(echo $@ | sed 's/:.*//')
    echo "Connecting to $label ($host)"
    ssh-keygen -f "$HOME/.ssh/known_hosts" -R "$host"
    rsync -av ~/.ec2_skel/ $host:~/
    ssh -t $host exec zsh
}

update_ec2(){
    "$HOME/.ec2/list_instances.py"
}

_ec2ssh(){
    reply=(`cat ~/.ec2/instances`)
}
compctl -K _ec2ssh ec2ssh

alias s='sudo -i zsh'
# s(){
#     sudo su -m $@ -c 'exec zsh'
# }

# Virtualenvwrapper stuff
export WORKON_HOME="${HOME}/envs/"
export PROJECT_HOME="${HOME}/workspace/"
#export DISPLAY=:0

if which pyenv &> /dev/null; then
# eval "$(pyenv init -)"; fi
	export PATH="/Users/rick/.pyenv/shims:${PATH}"
	export PYENV_SHELL=zsh
	source /usr/local/Cellar/pyenv/*/libexec/../completions/pyenv.zsh
	# command pyenv rehash 2>/dev/null
	pyenv() {
  	local command
  	command="${1:-}"
  	if [ "$#" -gt 0 ]; then
    	shift
  	fi

  	case "$command" in
  	activate|deactivate|rehash|shell|virtualenvwrapper|virtualenvwrapper_lazy)
    	eval "$(pyenv "sh-$command" "$@")";;
  	*)
    	command pyenv "$command" "$@";;
  	esac
	}

	pyenv virtualenvwrapper_lazy
elif [ -f /usr/share/virtualenvwrapper/virtualenvwrapper.sh ]; then
    . /usr/share/virtualenvwrapper/virtualenvwrapper.sh
elif which virtualenvwrapper.sh > /dev/null; then
    . $(which virtualenvwrapper.sh)
fi

# else
#     . $(which virtualenvwrapper.sh)
#     # if ! command_exists original_workon; then
#     #     eval "$(echo "original_workon() {"; declare -f workon | tail -n +2)"
#     # fi
# 
#     # # No need for mount_workon anymore, perhaps in the future
#     # # . ${ROOT_DIR}bin/mount_workon
#     # workon(){
#     #     project_dir="${PROJECT_HOME}$1"
#     #     env_dir="${WORKON_HOME}$1"
#     #     if [ ! -d "$project_dir" ] && [ ! -d "$env_dir" ]; then
#     #         mkproject "$1"
#     #         cd "$project_dir"
#     #     elif [ -d "$env_dir" ]; then
#     #         original_workon "$1"
#     #     else
#     #         echo "No virtualenv $1, simply doing a cd to $project_dir"
#     #         test -d "$project_dir" && cd "$project_dir"
#     #     fi
#     # }
# fi
#

_workon_if_possible(){
    if [ "$1" = '/' ] || [ "$1" = 'root' ]; then
        return false;
    fi

    if [ -e "$WORKON_HOME/$1" ] || [ -e "$WORKON_HOME/$1.sparseimage*" ]; then
        echo "Working on ~/envs/$1"
        workon "$1"
        _virtualenv_tmux_name
        return true
    fi
    return false
}

_virtualenv_tmux_name(){
    if [ -n "$TMUX" ] && [ -z "$VIRTUAL_ENV" ]; then
        session_name=${VIRTUAL_ENV%%/.venv}
        session_name=${session_name##.*/}
        echo "session name: $session_name"
        export PS1="($session_name)$ORIGINAL_PS1"
        echo -ne "\e]0;$session_name\a"
    fi
}

# Auto active virtualenv for the current directory
activate(){
    if [ -e ".venv/bin/activate" ]; then
        echo "Activating pipenv in $PWD/.venv"
# . .venv/bin/activate  # commented out by conda initialize
        _virtualenv_tmux_name

        # the pipenv shell normally enables these as well
        export PYTHONDONTWRITEBYTECODE=1
        export PIPENV_ACTIVE=1

    elif [ -e "activate" ]; then
        echo "Activating using $PWD/activate"
        . ./activate
        _virtualenv_tmux_name
    else
        # activate if our current dir or our parent dir is the name of a
        # virtualenv
        _workon_if_possible $(basename "$PWD")
        _workon_if_possible $(basename $(dirname "$(pwd)"))
    fi

    if [ -f "${VIRTUAL_ENV}/.project" ]; then
        cd $(cat "${VIRTUAL_ENV}/.project")
    fi
}

# activate virtualenv automatically
if [[ -z "$VIRTUAL_ENV" || -n "$TMUX" ]]; then
    activate
fi

# # reset all bindkeys, this makes vi mode work _much_ faster
# bindkey -rpM viins '\e'

# Vim mode
bindkey -v

export KEYTIMEOUT=1

#Rebind HOME and END to do the decent thing:
bindkey '^[[1~' beginning-of-line
bindkey '^[[4~' end-of-line
bindkey '^[[H' beginning-of-line
bindkey '^[[F' end-of-line
bindkey '^[[1;5D' backward-word
bindkey '^[[1;5C' forward-word
case $TERM in (xterm*)
	bindkey '\eOH' beginning-of-line
	bindkey '\eOF' end-of-line
esac

autoload -U edit-command-line
zle -N edit-command-line
bindkey '^E' edit-command-line

#And DEL too, as well as PGDN and insert:
bindkey '^[[3~' delete-char
bindkey '^[[6~' end-of-history
#bindkey '\e[2~' redisplay

#Now bind pgup to paste the last word of the last command,
bindkey '\e[5~' insert-last-word

# History search should use patterns on 5.x and normal search on 4.x or lower
if [[ "$ZSH_VERSION" < 5 ]]; then
    bindkey '^R' history-incremental-search-backward
    bindkey '^S' history-incremental-search-forward
    bindkey '^Xr' history-incremental-search-backward
    bindkey '^Xs' history-incremental-search-forward
else
    bindkey '^R' history-incremental-pattern-search-backward
    bindkey '^S' history-incremental-pattern-search-forward
    bindkey '^Xr' history-incremental-pattern-search-backward
    bindkey '^Xs' history-incremental-pattern-search-forward
fi

bindkey '^[[A' up-line-or-history
bindkey '^[[B' down-line-or-history
bindkey '^[[C' forward-char
bindkey '^[[D' backward-char

# Color listing
export LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
export CLICOLOR=true
export LSCOLORS=Exfxcxdxbxegedabagacad

zstyle ':completion:*' list-colors 'reply=( "=(#b)(*$VAR)(?)*=00=$color[green]=$color[bg-green]" )'
zstyle ':completion:*:*:tmx:*:active-sessions' list-colors '=*=228;0'

# history settings
HISTSIZE=10000000
SAVEHIST=10000000

setopt BANG_HIST                 # Treat the '!' character specially during expansion.
setopt EXTENDED_HISTORY          # Write the history file in the ":start:elapsed;command" format.
setopt INC_APPEND_HISTORY        # Write to the history file immediately, not when the shell exits.
setopt SHARE_HISTORY             # Share history between all sessions.
setopt HIST_EXPIRE_DUPS_FIRST    # Expire duplicate entries first when trimming history.
setopt HIST_IGNORE_DUPS          # Don't record an entry that was just recorded again.
setopt HIST_IGNORE_ALL_DUPS      # Delete old recorded entry if new entry is a duplicate.
setopt HIST_FIND_NO_DUPS         # Do not display a line previously found.
setopt HIST_IGNORE_SPACE         # Don't record an entry starting with a space.
setopt HIST_SAVE_NO_DUPS         # Don't write duplicate entries in the history file.
setopt HIST_REDUCE_BLANKS        # Remove superfluous blanks before recording entry.
setopt HIST_VERIFY               # Don't execute immediately upon history expansion.
setopt HIST_BEEP                 # Beep when accessing nonexistent history.


if [ -f "$PWD/.zshhistory" ]; then
    export HISTFILE="$PWD/.zshhistory"
else
    export HISTFILE=~/.zshhistory
fi

# The maximum amount of search results to show in autocompletion
LISTMAX=250

# use /etc/hosts and known_hosts for hostname completion
[ -r /etc/ssh/ssh_known_hosts ] && _global_ssh_hosts=(${${${${(f)"$(</etc/ssh/ssh_known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _ssh_hosts=()
[ -r ~/.ssh/known_hosts ] && _ssh_hosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _ssh_hosts=()
[ -r /etc/hosts ] && : ${(A)_etc_hosts:=${(s: :)${(ps:\t:)${${(f)~~"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}} || _etc_hosts=()
# [ -r ~/.ssh/config ] && _ssh_config_hosts=(${(s: :)${(ps:\t:)${(f)"$(<$HOME/.ssh/config|grep 'Host' | grep -v '\*')"}#Host}#Hostname}) || _ssh_config_hosts=()

hosts=(
  "$_global_ssh_hosts[@]"
  "$_ssh_hosts[@]"
  "$_etc_hosts[@]"
  "$_ssh_config_hosts[@]"
  "$HOST"
  localhost
)

_zpcompinit_custom() {
  setopt extendedglob local_options
  autoload -Uz compinit
  local zcd=${ZDOTDIR:-$HOME}/.zcompdump
  local zcdc="$zcd.zwc"
  # Compile the completion dump to increase startup speed, if dump is newer or doesn't exist,
  # in the background as this is doesn't affect the current session
  # if [[ -f "$zcd"(#qN.m+1) ]]; then
  #       compinit -i -d "$zcd"
  #       { rm -f "$zcdc" && zcompile "$zcd" } &!
  # else
  #       compinit -C -d "$zcd"
  #       { [[ ! -f "$zcdc" || "$zcd" -nt "$zcdc" ]] && rm -f "$zcdc" && zcompile "$zcd" } &!
  # fi
  compinit
}

autoload bashcompinit
bashcompinit
_zpcompinit_custom


# Group matches and describe.
zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion:*:matches' group 'yes'
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*:options' auto-description '%d'
zstyle ':completion:*:corrections' format ' %F{green}-- %d (errors: %e) --%f'
zstyle ':completion:*:descriptions' format ' %F{yellow}-- %d --%f'
zstyle ':completion:*:messages' format ' %F{purple} -- %d --%f'
zstyle ':completion:*:warnings' format ' %F{red}-- no matches found --%f'
zstyle ':completion:*:default' list-prompt '%S%M matches%s'
zstyle ':completion:*' format ' %F{yellow}-- %d --%f'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' verbose yes

# Expansion options
zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate
zstyle ':completion:*' matcher-list '' 'm:{[:lower:]}={[:upper:]}' 'l:|=* r:|=*' 'r:|[._-]=** r:|=**'
zstyle ':completion::prefix-1:*' completer _complete
zstyle ':completion:incremental:*' completer _complete _correct
zstyle ':completion:predict:*' completer _complete
zstyle ':completion:*:match:*' original only
zstyle ':completion:*:approximate:*' max-errors 1 numeric

# Increase the number of errors based on the length of the typed word.
zstyle -e ':completion:*:approximate:*' max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3))numeric)'

# Don't complete unavailable commands.
zstyle ':completion:*:functions' ignored-patterns '(_*|pre(cmd|exec))'

# Array completion element sorting.
zstyle ':completion:*:*:-subscript-:*' tag-order indexes parameters

zstyle ':completion:*' group-name ''
zstyle ':completion:*:complete:mpv:*' tag-order '!urls'
zstyle ':completion:*:complete:mplayer:*' tag-order '!urls'
zstyle ':completion:*:complete:vlc:*' tag-order '!urls'

zstyle ':completion:*:ssh:*' hosts $hosts
zstyle ':completion:*:slogin:*' hosts $hosts

# Completion caching
zstyle ':completion::complete:*' use-cache 1
zstyle ':completion::complete:*' cache-path ~/.zsh/cache/$HOST

# Expand partial paths
zstyle ':completion:*' expand 'yes'

# Directories
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*:*:cd:*' tag-order local-directories directory-stack path-directories
zstyle ':completion:*:*:cd:*:directory-stack' menu yes select
zstyle ':completion:*:-tilde-:*' group-order 'named-directories' 'path-directories' 'users' 'expand'
zstyle ':completion:*' squeeze-slashes true

# History
zstyle ':completion:*:history-words' stop yes
zstyle ':completion:*:history-words' remove-all-dups yes
zstyle ':completion:*:history-words' list false
zstyle ':completion:*:history-words' menu yes

# Include non-hidden directories in globbed file completions
# for certain commands

zstyle ':completion::complete:*' '\'

# tag-order 'globbed-files directories' all-files
zstyle ':completion::complete:*:tar:directories' file-patterns '*~.*(-/)'

# Don't complete backup files as executables
zstyle ':completion:*:complete:-command-::commands' ignored-patterns '*\~'

# Don't complete files that vim shouldn't handle
zstyle ':completion:*:*:(vi|vim|nvim|vimdiff):*:*' ignored-patterns '*?.pyc' \
    '*?.pyo' '*?.pdf' '*?.o'
# zstyle ':completion:*:*:(vi|vim|nvim|vimdiff):*:directories' ignored-patterns \
#     '(*/)*.egg-info'

# Ignore these everywhere except for rm
zstyle ':completion:*:*:*' ignored-patterns '(|*/)__pycache__' \
    '(|*/)*.egg-info' '(*/)#lost+found'
zstyle ':completion:*:rm:*' ignored-patterns

# Ignore completion functions
zstyle ':completion:*:functions' ignored-patterns '_*'

# Ignore what's already in the line
# With commands like `rm/kill/diff' it's annoying if one gets offered the same
# filename again even if it is already on the command line. To avoid that:
zstyle ':completion:*:(rm|kill|diff):*' ignore-line yes

# Ignore parent directory
# Useful for cd, mv and cp. Ex, cd will never select the parent directory (ie
# cd ../<TAB>):
zstyle ':completion:*:(cd|mv|cp):*' ignore-parents parent pwd

# Separate matches into groups
zstyle ':completion:*:matches' group 'yes'

# Describe each match group.
zstyle ':completion:*:descriptions' format "%B---- %d%b"

# Messages/warnings format
zstyle ':completion:*:messages' format '%B%U---- %d%u%b'
zstyle ':completion:*:warnings' format '%B%U---- no match for: %d%u%b'

# Describe options in full
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*:options' auto-description '%d'

zstyle ':completion:*' rehash true
zstyle ':completion:*' menu select=2

# start menu completion only if it could find no unambiguous initial string
zstyle ':completion:*:correct:*'       insert-unambiguous true
zstyle ':completion:*:man:*'      menu yes select
# activate menu
zstyle ':completion:*:history-words'   menu yes                            
# complete 'cd -<tab>' with menu
zstyle ':completion:*:*:cd:*:directory-stack' menu yes select              
zstyle ':completion:*' menu select=5

# No shared history between tabs
unsetopt sharehistory

for i in \
    /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh \
    /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh \
; do
    if [ -e "$i" ]; then
        source "$i"
    fi
done

export ZSH_AUTOSUGGEST_MANUAL_REBIND=true
export ZSH_AUTOSUGGEST_USE_ASYNC=true
export ZSH_AUTOSUGGEST_STRATEGY=(history)
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20

if [ -d ~/.zsh/plugins/ ]; then
    for f in ~/.zsh/plugins/*sh; do
        . "$f"
    done
fi


if [ -f ~/.fzf.zsh ]; then
    source ~/.fzf.zsh

    fzf-history-widget-accept() {
        local selected num
        setopt localoptions noglobsubst pipefail 2> /dev/null
        # selected=( $(fc -l 1 | eval "$(__fzfcmd) +s --tac +m -n2..,.. --tiebreak=index --toggle-sort=ctrl-r $FZF_CTRL_R_OPTS -q ${(q)LBUFFER}") )
        selected=( $(fc -l 1 | eval "$(__fzfcmd) +s --tac +m -n2..,.. --tiebreak=index --toggle-sort=ctrl-r --expect=tab,ctrl-e,left,right $FZF_CTRL_R_OPTS -q ${(q)LBUFFER}") )

        local ret=$?
        if [ -n "$selected" ]; then
            local accept=1
            local edit=0
            if [[ $selected[1] = tab || $selected[1] = left || $selected[1] = right ]]; then
                accept=0
                shift selected
            elif [[ $selected[1] = ctrl-e ]]; then
                edit=1
                shift selected
            fi

            num=$selected[1]
            if [ -n "$num" ]; then
                zle vi-fetch-history -n $num
                [[ $accept = 1 ]] && zle accept-line
                [[ $edit = 1 ]] && zle edit-command-line
            fi
        fi
        zle redisplay
        typeset -f zle-line-init >/dev/null && zle zle-line-init
        return $ret
    }
    zle     -N      fzf-history-widget-accept
    bindkey '^R'    fzf-history-widget-accept

    if command_exists pt; then
        export FZF_DEFAULT_COMMAND='pt --global-gitignore -g ""'
    elif command_exists ag; then
        export FZF_DEFAULT_COMMAND='ag --follow -g "" . site-packages '
    fi
    export FZF_DEFAULT_OPTS='--no-mouse'
elif [ -f /usr/local/share/examples/fzf/shell/completion.zsh ]; then
    echo "source /usr/local/share/examples/fzf/shell/completion.zsh" > ~/.fzf.zsh
    echo "source /usr/local/share/examples/fzf/shell/key-bindings.zsh" >> ~/.fzf.zsh
fi

test -f "${ROOT_DIR}.zshrc_local" && source "${ROOT_DIR}.zshrc_local"
test -f "${ROOT_DIR}.zshrc.local" && source "${ROOT_DIR}.zshrc.local"

export PATH="$HOME/.yarn/bin:$HOME/.config/yarn/global/node_modules/.bin:$PATH"

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

###-begin-pm2-completion-###
### credits to npm for the completion file model
#
# Installation: pm2 completion >> ~/.bashrc  (or ~/.zshrc)
#

COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}
COMP_WORDBREAKS=${COMP_WORDBREAKS/@/}
export COMP_WORDBREAKS

if type complete &>/dev/null; then
  _pm2_completion () {
    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           pm2 completion -- "${COMP_WORDS[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -o default -F _pm2_completion pm2
elif type compctl &>/dev/null; then
  _pm2_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       pm2 completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _pm2_completion + -f + pm2
fi
###-end-pm2-completion-###

export PATH="/usr/local/opt/gnu-getopt/bin:$PATH"
export PATH="/usr/local/opt/helm@2/bin:$PATH"
export PATH="/usr/local/opt/helm@2/bin:$PATH"

if [ 1 -eq "$DEBUG" ]; then
    # turn off tracing
    unsetopt xtrace
    # restore stderr to the value saved in FD 3
    exec 2>&3 3>&-
    zprof
fi
